# Corporate Dockerfile with aggressive proxy/SSL handling
# Use this when standard Dockerfile fails due to proxy/firewall issues

FROM python:3.11-slim

# Accept proxy settings as build arguments
ARG HTTP_PROXY
ARG HTTPS_PROXY
ARG NO_PROXY
ARG NODE_TLS_REJECT_UNAUTHORIZED=0
ARG PYTHONHTTPSVERIFY=0

# Set all possible proxy environment variables
ENV HTTP_PROXY=${HTTP_PROXY} \
    HTTPS_PROXY=${HTTPS_PROXY} \
    NO_PROXY=${NO_PROXY} \
    http_proxy=${HTTP_PROXY} \
    https_proxy=${HTTPS_PROXY} \
    no_proxy=${NO_PROXY} \
    NODE_TLS_REJECT_UNAUTHORIZED=${NODE_TLS_REJECT_UNAUTHORIZED} \
    PYTHONHTTPSVERIFY=${PYTHONHTTPSVERIFY} \
    REQUESTS_CA_BUNDLE="" \
    CURL_CA_BUNDLE="" \
    SSL_CERT_FILE="" \
    SSL_CERT_DIR="" \
    PIP_CERT="" \
    PIP_TRUSTED_HOST="pypi.org pypi.python.org files.pythonhosted.org"

# Configure apt for proxy
RUN if [ -n "$HTTP_PROXY" ]; then \
        echo "Acquire::http::Proxy \"$HTTP_PROXY\";" > /etc/apt/apt.conf.d/proxy.conf && \
        echo "Acquire::https::Proxy \"$HTTPS_PROXY\";" >> /etc/apt/apt.conf.d/proxy.conf; \
    fi

# Install system dependencies
RUN apt-get update && apt-get install -y \
    wget \
    curl \
    gnupg \
    ca-certificates \
    fonts-liberation \
    libasound2 \
    libatk-bridge2.0-0 \
    libatk1.0-0 \
    libcups2 \
    libdbus-1-3 \
    libdrm2 \
    libgbm1 \
    libglib2.0-0 \
    libgtk-3-0 \
    libnspr4 \
    libnss3 \
    libx11-6 \
    libxcb1 \
    libxcomposite1 \
    libxdamage1 \
    libxext6 \
    libxfixes3 \
    libxkbcommon0 \
    libxrandr2 \
    xdg-utils \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy poetry files
COPY pyproject.toml poetry.lock ./

# Configure pip for proxy and install poetry
RUN if [ -n "$HTTP_PROXY" ]; then \
        pip config set global.proxy $HTTP_PROXY && \
        pip config set global.trusted-host "pypi.org pypi.python.org files.pythonhosted.org"; \
    fi && \
    pip install --no-cache-dir \
        --trusted-host pypi.org \
        --trusted-host pypi.python.org \
        --trusted-host files.pythonhosted.org \
        poetry==1.8.5

# Configure poetry and install dependencies
RUN poetry config virtualenvs.create false && \
    poetry config installer.max-workers 1 && \
    poetry config http-basic.pypi "" "" && \
    poetry install --no-interaction --no-ansi --no-root --only main || \
    (echo "Retrying with --no-cache..." && \
     poetry cache clear pypi --all && \
     poetry install --no-interaction --no-ansi --no-root --only main)

# Try to pre-cache tldextract, but don't fail if it doesn't work
RUN python -c "import os; \
    os.environ['REQUESTS_CA_BUNDLE'] = ''; \
    os.environ['TLDEXTRACT_CACHE'] = '/app/.tld_cache'; \
    try: \
        import tldextract; \
        tldextract.extract('example.com'); \
        print('Public suffix list cached successfully'); \
    except Exception as e: \
        print(f'Could not cache public suffix list: {e}'); \
        print('Will use fallback domain parsing');" || true

# Install Playwright with multiple fallback options
RUN export PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD=0 && \
    if [ -n "$HTTPS_PROXY" ]; then \
        # Try with proxy first
        (HTTPS_PROXY=$HTTPS_PROXY playwright install chromium) || \
        # Try without SSL verification
        (NODE_TLS_REJECT_UNAUTHORIZED=0 playwright install chromium) || \
        # Try downloading directly with curl
        (echo "Downloading Chromium manually..." && \
         curl -kL -x $HTTPS_PROXY https://playwright.azureedge.net/builds/chromium/chromium-linux.zip -o chromium.zip && \
         playwright install-deps chromium) || \
        echo "Warning: Could not install Chromium, container may not work properly"; \
    else \
        playwright install chromium; \
    fi

# Copy application code
COPY src/ ./src/
COPY production_scanner.py url_handler.py ./

# Create directories
RUN mkdir -p /app/input /app/output /app/.tld_cache

# Set Python path
ENV PYTHONPATH=/app:/app/src

# Add a fallback domain parser in case tldextract fails
RUN cat > /app/fallback_domain_parser.py << 'EOF'
import re
from urllib.parse import urlparse

def extract_domain(url):
    """Simple fallback domain extractor when tldextract fails"""
    if not url.startswith(('http://', 'https://')):
        url = 'https://' + url
    parsed = urlparse(url)
    domain = parsed.netloc or parsed.path.split('/')[0]
    # Remove port if present
    domain = domain.split(':')[0]
    # Remove www. prefix
    if domain.startswith('www.'):
        domain = domain[4:]
    return domain
EOF

# Runtime proxy configuration for the application
ENV PLAYWRIGHT_BROWSERS_PATH=/app/pw-browsers \
    TLDEXTRACT_CACHE=/app/.tld_cache

ENTRYPOINT ["python", "/app/production_scanner.py"]
CMD ["--help"]